<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü—Å–∏—Ö–æ–º–æ—Å—Ç: –ó–∞–±—ã—Ç—ã–µ –í–æ—Å–ø–æ–º–∏–Ω–∞–Ω–∏—è</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* –û—Å–Ω–æ–≤–Ω—ã–µ —Å—Ç–∏–ª–∏ –¥–ª—è body –∏ game-container */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* –¢–µ–º–Ω—ã–π —Ñ–æ–Ω */
            color: #e0e0e0; /* –°–≤–µ—Ç–ª—ã–π —Ç–µ–∫—Å—Ç */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
        }
        .game-container {
            background-color: #16213e; /* –ù–µ–º–Ω–æ–≥–æ —Å–≤–µ—Ç–ª–µ–µ —Ç–µ–º–Ω—ã–π —Ñ–æ–Ω –¥–ª—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ */
            border-radius: 1.5rem; /* –°–∫—Ä—É–≥–ª–µ–Ω–Ω—ã–µ —É–≥–ª—ã */
            padding: 2rem;
            max-width: 900px;
            width: 100%;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            transition: background-color 1s ease-in-out, background-image 1s ease-in-out; /* –ü–ª–∞–≤–Ω—ã–π –ø–µ—Ä–µ—Ö–æ–¥ –¥–ª—è —Ñ–æ–Ω–æ–≤ */
            overflow: hidden; /* –û–±—Ä–µ–∑–∞–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ, –≤—ã—Ö–æ–¥—è—â–µ–µ –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã, –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ */
            position: relative; /* –î–ª—è –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –ø—Å–µ–≤–¥–æ—ç–ª–µ–º–µ–Ω—Ç–æ–≤/—Å–ª–æ–µ–≤ */
        }

        /* –ê–Ω–∏–º–∞—Ü–∏–∏ —Ñ–æ–Ω–æ–≤ */
        @keyframes pulse-red {
            0% { box-shadow: 0 0 15px rgba(255, 0, 0, 0.3); }
            50% { box-shadow: 0 0 30px rgba(255, 0, 0, 0.6); }
            100% { box-shadow: 0 0 15px rgba(255, 0, 0, 0.3); }
        }

        @keyframes digital-flow {
            0% { background-position: 0% 0%; }
            100% { background-position: 100% 100%; }
        }

        @keyframes subtle-glow {
            0% { filter: brightness(1); }
            50% { filter: brightness(1.1); }
            100% { filter: brightness(1); }
        }

        /* –ö–ª–∞—Å—Å—ã —Ñ–æ–Ω–æ–≤ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Å—Ü–µ–Ω */
        .bg-prologue {
            background-color: #0d0d1a;
            animation: pulse-red 2s infinite alternate;
        }

        .bg-nova-lab {
            background: linear-gradient(135deg, #16213e, #0f3460);
            position: relative;
            z-index: 1;
        }
        .bg-nova-lab::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: linear-gradient(0deg, transparent 50%, rgba(25, 255, 255, 0.05) 50%),
                               linear-gradient(90deg, transparent 50%, rgba(25, 255, 255, 0.05) 50%);
            background-size: 20px 20px;
            z-index: -1;
            opacity: 0.2;
            animation: digital-flow 100s linear infinite;
        }

        .bg-megapolis {
            background: linear-gradient(45deg, #1a1a2e, #0d1226);
            position: relative;
            z-index: 1;
        }
        .bg-megapolis::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: radial-gradient(circle at bottom right, rgba(0, 200, 255, 0.1), transparent 50%),
                               radial-gradient(circle at top left, rgba(255, 100, 0, 0.08), transparent 50%);
            background-size: 100% 100%;
            animation: subtle-glow 8s infinite alternate;
            z-index: -1;
        }

        .bg-psychobridge {
            background: linear-gradient(180deg, #0f3460, #16213e);
            position: relative;
            overflow: hidden;
            z-index: 1;
        }
        .bg-psychobridge::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 10 10"><circle cx="5" cy="5" r="1" fill="%23e94560" opacity="0.5"/></svg>'); /* –ú–∞–ª–µ–Ω—å–∫–∏–µ –ø—É–ª—å—Å–∏—Ä—É—é—â–∏–µ —Ç–æ—á–∫–∏ */
            background-size: 20px 20px;
            animation: digital-flow 30s linear infinite;
            z-index: -1;
            opacity: 0.3;
        }
        .bg-psychobridge::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(233, 69, 96, 0.1) 10%, transparent 80%);
            animation: pulse-red 4s infinite alternate;
            z-index: -1;
        }

        .bg-climax {
            background: linear-gradient(180deg, #2a0000, #0a0a0a);
            animation: pulse-red 1s infinite alternate; /* –ë–æ–ª–µ–µ –∞–≥—Ä–µ—Å—Å–∏–≤–Ω–æ–µ –ø—É–ª—å—Å–∏—Ä–æ–≤–∞–Ω–∏–µ */
            position: relative;
            z-index: 1;
        }
        .bg-climax::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><line x1="0" y1="0" x2="100" y2="100" stroke="%23ff0000" stroke-width="1" opacity="0.3"/><line x1="100" y1="0" x2="0" y2="100" stroke="%23ff0000" stroke-width="1" opacity="0.3"/></svg>'); /* –°–µ—Ç–∫–∞ –∏–∑ –∫—Ä–∞—Å–Ω—ã—Ö –ª–∏–Ω–∏–π */
            background-size: 50px 50px;
            z-index: -1;
            animation: digital-flow 5s linear infinite;
        }

        /* –°—Ç–∏–ª—å –¥–ª—è –∫–Ω–æ–ø–æ–∫ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫ */
        .stat-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #b0b0b0;
            flex-grow: 1; /* –ü–æ–∑–≤–æ–ª—è–µ—Ç —ç–ª–µ–º–µ–Ω—Ç–∞–º —Ä–∞—Å—Ç–∏ –∏ –∑–∞–Ω–∏–º–∞—Ç—å –¥–æ—Å—Ç—É–ø–Ω–æ–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ */
            min-width: 120px; /* –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —à–∏—Ä–∏–Ω–∞ –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö */
            justify-content: center; /* –¶–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ */
            position: relative; /* –î–ª—è –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –≤—Å–ø–ª—ã–≤–∞—é—â–∏—Ö –∏–∑–º–µ–Ω–µ–Ω–∏–π */
        }
        .stat-value {
            font-weight: bold;
            color: #e94560; /* –ê–∫—Ü–µ–Ω—Ç–Ω—ã–π —Ü–≤–µ—Ç */
        }

        /* –°—Ç–∏–ª–∏ –¥–ª—è –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–æ–≤ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫ */
        .progress-bar-container {
            width: 60px; /* –®–∏—Ä–∏–Ω–∞ –ø–æ–ª–æ—Å–∫–∏ */
            height: 8px; /* –í—ã—Å–æ—Ç–∞ –ø–æ–ª–æ—Å–∫–∏ */
            background-color: #3b3b4d;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }
        .progress-bar-fill {
            height: 100%;
            background-color: #e94560; /* –¶–≤–µ—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è */
            width: 0%; /* –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ 0% */
            transition: width 0.5s ease-out; /* –ü–ª–∞–≤–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ —à–∏—Ä–∏–Ω—ã */
            border-radius: 4px;
        }
        /* –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ü–≤–µ—Ç–∞ –¥–ª—è —Ä–µ–ø—É—Ç–∞—Ü–∏–π */
        .progress-bar-fill.rep-nova-lab { background-color: #00bcd4; } /* Cyan */
        .progress-bar-fill.rep-ghosts { background-color: #9c27b0; } /* Purple */
        .progress-bar-fill.rep-rafi { background-color: #ff9800; } /* Orange */

        /* –°—Ç–∏–ª–∏ –¥–ª—è –≤—Å–ø–ª—ã–≤–∞—é—â–∏—Ö –∏–∑–º–µ–Ω–µ–Ω–∏–π —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫ */
        .stat-change-feedback {
            position: absolute;
            top: -15px; /* –í—ã—à–µ —Å—Ç–∞—Ç–∞ */
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.9rem;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.5s ease-out, transform 0.5s ease-out;
            pointer-events: none; /* –ù–µ –±–ª–æ–∫–∏—Ä—É–µ—Ç –∫–ª–∏–∫–∏ */
        }
        .stat-change-feedback.show {
            opacity: 1;
            transform: translateX(-50%) translateY(-10px); /* –ê–Ω–∏–º–∞—Ü–∏—è –≤–≤–µ—Ä—Ö */
        }
        .stat-change-feedback.increase {
            color: #4CAF50; /* –ó–µ–ª–µ–Ω—ã–π –¥–ª—è —É–≤–µ–ª–∏—á–µ–Ω–∏—è */
        }
        .stat-change-feedback.decrease {
            color: #e94560; /* –ö—Ä–∞—Å–Ω—ã–π –¥–ª—è —É–º–µ–Ω—å—à–µ–Ω–∏—è */
        }

        /* –°—Ç–∏–ª–∏ –¥–ª—è –∫–Ω–æ–ø–æ–∫ –≤—ã–±–æ—Ä–∞ */
        .choice-button {
            background-color: #0f3460; /* –°–∏–Ω–µ–≤–∞—Ç–æ-—Å–µ—Ä—ã–π —Ü–≤–µ—Ç –∫–Ω–æ–ø–∫–∏ */
            color: #ffffff;
            padding: 0.75rem 1.25rem;
            border-radius: 0.75rem;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out, box-shadow 0.2s ease-in-out;
            cursor: pointer;
            font-size: 1rem;
            text-align: left;
            border: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        .choice-button:hover {
            background-color: #1a4f8a;
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
        }
        .choice-button:active {
            background-color: #0c2d54;
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .choice-button:disabled {
            background-color: #3b3b4d;
            cursor: not-allowed;
            opacity: 0.7;
        }
        /* –°—Ç–∏–ª–∏ –¥–ª—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –º–∏–Ω–∏-–∏–≥—Ä */
        .mini-game-container {
            background-color: #0f3460;
            border-radius: 1rem;
            padding: 1.5rem;
            margin-top: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            align-items: center;
        }
        /* –°—Ç–∏–ª–∏ –¥–ª—è Canvas */
        canvas {
            background-color: #2e2e4a;
            border-radius: 0.75rem;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
            width: 100%; /* –î–µ–ª–∞–µ–º canvas –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–º */
            max-width: 600px; /* –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —à–∏—Ä–∏–Ω–∞ –¥–ª—è –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏ */
            height: 400px; /* –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤—ã—Å–æ—Ç–∞ –¥–ª—è canvas, —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ —Å—Ç–æ—Ä–æ–Ω –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è JS */
        }
        /* –°—Ç–∏–ª–∏ –¥–ª—è Memory Hack –º–∏–Ω–∏-–∏–≥—Ä—ã */
        .memory-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
        }
        .memory-card {
            background-color: #2e2e4a;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5rem; /* –ë–æ–ª—å—à–∏–π —Ä–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞ –¥–ª—è —ç–º–æ–¥–∑–∏ */
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.3s;
            color: transparent; /* –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ —Å–∫—Ä—ã–≤–∞–µ–º —ç–º–æ–¥–∑–∏ */
            user-select: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            perspective: 1000px; /* –î–ª—è 3D-—ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–µ—Ä–µ–≤–æ—Ä–æ—Ç–∞ */
        }
        .memory-card .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }
        .memory-card.flipped .card-inner {
            transform: rotateY(180deg);
        }
        .memory-card .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 8px;
        }
        .memory-card .card-front {
            background-color: #2e2e4a;
            color: transparent;
        }
        .memory-card .card-back {
            background-color: #3f6fa0;
            color: #ffffff;
            transform: rotateY(180deg);
        }
        .memory-card.matched .card-back {
            background-color: #4CAF50; /* –ó–µ–ª–µ–Ω—ã–π –¥–ª—è —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π */
            color: #ffffff;
            cursor: default;
        }
        /* –°—Ç–∏–ª–∏ –¥–ª—è Decryptor –º–∏–Ω–∏-–∏–≥—Ä—ã */
        .decryptor-input-group {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            flex-wrap: wrap; /* –†–∞–∑—Ä–µ—à–∏—Ç—å –ø–µ—Ä–µ–Ω–æ—Å –¥–ª—è –º–∞–ª–µ–Ω—å–∫–∏—Ö —ç–∫—Ä–∞–Ω–æ–≤ */
            justify-content: center;
        }
        .decryptor-input {
            width: 40px;
            height: 40px;
            text-align: center;
            font-size: 1.2rem;
            border-radius: 8px;
            border: 1px solid #4a4a66;
            background-color: #1a1a2e;
            color: #ffffff;
            outline: none;
        }
        .decryptor-button {
            background-color: #e94560;
            color: white;
            padding: 0.6rem 1.2rem;
            border-radius: 0.5rem;
            cursor: pointer;
            border: none;
            transition: background-color 0.2s;
        }
        .decryptor-button:hover {
            background-color: #ff6f88;
        }
        /* –°—Ç–∏–ª–∏ –¥–ª—è Energy Flow –º–∏–Ω–∏-–∏–≥—Ä—ã */
        .energy-node {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        .energy-input {
            width: 80px;
            padding: 0.5rem;
            font-size: 1.1rem;
            text-align: center;
            border-radius: 0.5rem;
            border: 1px solid #4a4a66;
            background-color: #1a1a2e;
            color: #ffffff;
            outline: none;
        }
        .energy-buttons button {
            background-color: #0f3460;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            border: none;
            margin: 0 0.25rem;
            transition: background-color 0.2s;
        }
        .energy-buttons button:hover {
            background-color: #1a4f8a;
        }
        /* –°—Ç–∏–ª–∏ –¥–ª—è –∫–Ω–æ–ø–æ–∫ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è/–∑–∞–≥—Ä—É–∑–∫–∏ */
        .save-load-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
            flex-wrap: wrap; /* –î–ª—è –∞–¥–∞–ø—Ç–∞—Ü–∏–∏ –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö */
        }
        .save-load-button {
            background-color: #4CAF50; /* –ó–µ–ª–µ–Ω—ã–π –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è/–∑–∞–≥—Ä—É–∑–∫–∏ */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            cursor: pointer;
            border: none;
            transition: background-color 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        .save-load-button:hover {
            background-color: #6bc071;
            transform: translateY(-2px);
        }

        /* –ö–ª–∞—Å—Å—ã –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–µ—Ä–µ—Ö–æ–¥–∞ */
        .scene-transition-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            opacity: 0;
            transition: opacity 0.8s ease-in-out; /* –í—Ä–µ–º—è –ø–µ—Ä–µ—Ö–æ–¥–∞ */
            z-index: 100; /* –ü–æ–≤–µ—Ä—Ö –≤—Å–µ–≥–æ */
            pointer-events: none; /* –ù–µ –±–ª–æ–∫–∏—Ä—É–µ—Ç –∫–ª–∏–∫–∏ */
        }
        .scene-transition-overlay.fade-out {
            opacity: 1;
        }
        .scene-transition-overlay.fade-in {
            opacity: 0;
        }

        /* –°—Ç–∏–ª–∏ –¥–ª—è –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞ –∂—É—Ä–Ω–∞–ª–∞ */
        .modal { /* Base style for all modals */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            padding: 1rem;
        }
        .modal-content {
            background-color: #16213e;
            border-radius: 1.5rem;
            padding: 2rem;
            max-width: 700px;
            width: 100%;
            height: 80vh;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            gap: 1rem;
            overflow-y: auto;
        }
        .modal-close-button {
            background-color: #e94560;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            cursor: pointer;
            border: none;
            transition: background-color 0.2s ease-in-out;
            align-self: flex-end;
        }
        .modal-close-button:hover {
            background-color: #ff6f88;
        }
        .journal-entry {
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px dashed #3b3b4d;
        }
        .journal-entry:last-child {
            border-bottom: none;
        }
        .journal-entry h4 {
            font-weight: bold;
            color: #00bcd4;
            margin-bottom: 0.5rem;
        }

        /* Specific styles for save/load modal */
        .save-load-slot {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: #0f3460;
            padding: 0.75rem 1.25rem;
            border-radius: 0.75rem;
            margin-bottom: 0.5rem;
            flex-wrap: wrap; /* Allow wrapping on small screens */
            gap: 0.5rem;
        }
        .save-load-slot-info {
            flex-grow: 1;
        }
        .save-load-slot-buttons button {
            background-color: #4CAF50;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            border: none;
            transition: background-color 0.2s ease-in-out;
            margin-left: 0.5rem;
        }
        .save-load-slot-buttons button.load {
            background-color: #00bcd4;
        }
        .save-load-slot-buttons button:hover {
            filter: brightness(1.2);
        }
        .save-load-slot-buttons button:disabled {
            background-color: #3b3b4d;
            cursor: not-allowed;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div id="game-container" class="game-container bg-prologue">
        <h1 class="text-3xl font-bold text-center text-red-400 mb-4">–ü—Å–∏—Ö–æ–º–æ—Å—Ç: –ó–∞–±—ã—Ç—ã–µ –í–æ—Å–ø–æ–º–∏–Ω–∞–Ω–∏—è</h1>

        <div class="flex flex-wrap justify-center gap-4 mb-4">
            <div class="stat-item">
                <span class="font-bold">–õ–æ–≥–∏–∫–∞:</span> <span id="logic-stat" class="stat-value">0</span>
                <div class="progress-bar-container"><div id="logic-bar" class="progress-bar-fill"></div></div>
                <div id="logic-feedback" class="stat-change-feedback"></div>
            </div>
            <div class="stat-item">
                <span class="font-bold">–≠–º–ø–∞—Ç–∏—è:</span> <span id="empathy-stat" class="stat-value">0</span>
                <div class="progress-bar-container"><div id="empathy-bar" class="progress-bar-fill"></div></div>
                <div id="empathy-feedback" class="stat-change-feedback"></div>
            </div>
            <div class="stat-item">
                <span class="font-bold">–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è:</span> <span id="sync-stat" class="stat-value">0</span>
                <div class="progress-bar-container"><div id="sync-bar" class="progress-bar-fill"></div></div>
                <div id="sync-feedback" class="stat-change-feedback"></div>
            </div>
            <div class="stat-item">
                <span class="font-bold">–†–µ–ø—É—Ç–∞—Ü–∏—è –ù–æ–≤–∞ –õ–∞–±:</span> <span id="nova-lab-rep-stat" class="stat-value">0</span>
                <div class="progress-bar-container"><div id="nova-lab-rep-bar" class="progress-bar-fill rep-nova-lab"></div></div>
                <div id="nova-lab-rep-feedback" class="stat-change-feedback"></div>
            </div>
            <div class="stat-item">
                <span class="font-bold">–†–µ–ø—É—Ç–∞—Ü–∏—è –ü—Ä–∏–∑—Ä–∞–∫–æ–≤:</span> <span id="ghosts-rep-stat" class="stat-value">0</span>
                <div class="progress-bar-container"><div id="ghosts-rep-bar" class="progress-bar-fill rep-ghosts"></div></div>
                <div id="ghosts-rep-feedback" class="stat-change-feedback"></div>
            </div>
            <div class="stat-item">
                <span class="font-bold">–†–µ–ø—É—Ç–∞—Ü–∏—è –†–∞—Ñ–∏:</span> <span id="rafi-rep-stat" class="stat-value">0</span>
                <div class="progress-bar-container"><div id="rafi-rep-bar" class="progress-bar-fill rep-rafi"></div></div>
                <div id="rafi-rep-feedback" class="stat-change-feedback"></div>
            </div>
        </div>

        <div class="save-load-buttons">
            <button id="save-game-button" class="save-load-button">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–≥—Ä—É üíæ</button>
            <button id="load-game-button" class="save-load-button">–ó–∞–≥—Ä—É–∑–∏—Ç—å –∏–≥—Ä—É üìÇ</button>
            <button id="open-journal-button" class="save-load-button">–ñ—É—Ä–Ω–∞–ª üìî</button>
        </div>

        <div id="narrative-text" class="text-lg mb-6 leading-relaxed text-gray-300">
        </div>

        <div id="choices-container" class="flex flex-col gap-3">
        </div>

        <div id="mini-game-section" class="mini-game-container hidden">
            <h3 id="mini-game-title" class="text-2xl font-bold text-red-300 mb-3"></h3>
            <div id="mini-game-content" class="w-full">
            </div>
            <button id="mini-game-submit" class="decryptor-button hidden">–ó–∞–≤–µ—Ä—à–∏—Ç—å</button>
            <p id="mini-game-message" class="text-red-300"></p>
        </div>

        <div id="transition-overlay" class="scene-transition-overlay"></div>

        <div id="journal-modal" class="modal hidden">
            <div class="modal-content">
                <h2 class="text-3xl font-bold text-center text-red-400 mb-4">–ñ—É—Ä–Ω–∞–ª –í–æ—Å–ø–æ–º–∏–Ω–∞–Ω–∏–π</h2>
                <div id="journal-entries" class="text-left">
                </div>
                <button id="journal-close-button" class="modal-close-button">–ó–∞–∫—Ä—ã—Ç—å</button>
            </div>
        </div>

        <div id="save-load-modal" class="modal hidden">
            <div class="modal-content">
                <h2 class="text-3xl font-bold text-center text-red-400 mb-4">–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ / –ó–∞–≥—Ä—É–∑–∫–∞ –ò–≥—Ä—ã</h2>
                <div id="save-load-slots-container" class="flex flex-col gap-2">
                </div>
                <button id="save-load-close-button" class="modal-close-button">–ó–∞–∫—Ä—ã—Ç—å</button>
            </div>
        </div>
    </div>
    <script>
        // –ö–ª–∏–µ–Ω—Ç—Å–∫–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã (–ù–ï –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–Ω–æ–µ, —Å–ª—É–∂–∏—Ç –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è)
        let clientGameState = {
            logic: 5,
            empathy: 5,
            synchronization: 5,
            reputationNovaLab: 0,
            reputationGhosts: 0,
            reputationRafi: 0,
            secretPathCounter: 0,
            novaLabIsHostile: false,
            currentScene: 'prologue', // –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç—Å—è –¥–ª—è —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞ –Ω–∞ –∫–ª–∏–µ–Ω—Ç–µ
            currentMiniGame: null,
            journal: {}, // –ë—É–¥–µ—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–æ –¥–∞–Ω–Ω—ã–º–∏ —Å–µ—Ä–≤–µ—Ä–∞ –∏–ª–∏ —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω–æ–π –ª–æ–≥–∏–∫–æ–π –∫–ª–∏–µ–Ω—Ç–∞
            // –°–æ—Å—Ç–æ—è–Ω–∏—è –º–∏–Ω–∏-–∏–≥—Ä, —É–ø—Ä–∞–≤–ª—è–µ–º—ã–µ –Ω–∞ —Å—Ç–æ—Ä–æ–Ω–µ –∫–ª–∏–µ–Ω—Ç–∞ –≤–æ –≤—Ä–µ–º—è –∞–∫—Ç–∏–≤–Ω–æ–π –∏–≥—Ä—ã
            memoryHack: {
                cards: [],
                flippedCards: [],
                matchedPairs: 0,
                attempts: 0,
                symbols: ['üß†', 'üëª', 'üóùÔ∏è', 'üí°', 'üîó', 'üåê', 'üõ°Ô∏è', '‚ö°']
            },
            decryptor: {
                inputValues: [], // –ö–ª–∏–µ–Ω—Ç —É–ø—Ä–∞–≤–ª—è–µ—Ç –≤–≤–æ–¥–æ–º –¥–ª—è –º–∏–Ω–∏-–∏–≥—Ä—ã
            },
            energyFlow: {
                node1: 5, node2: 5, node3: 5, maxEnergy: 5, totalEnergy: 15
            },
            laserMaze: {
                playerX: 50, playerY: 200, playerSize: 20, lasers: [], laserSpeed: 2, gameRunning: false, canvas: null, ctx: null, animationFrameId: null
            }
        };

        // –≠–ª–µ–º–µ–Ω—Ç—ã DOM (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
        const gameContainerElem = document.getElementById('game-container');
        const narrativeTextElem = document.getElementById('narrative-text');
        const choicesContainerElem = document.getElementById('choices-container');
        const logicStatElem = document.getElementById('logic-stat');
        const empathyStatElem = document.getElementById('empathy-stat');
        const syncStatElem = document.getElementById('sync-stat');
        const novaLabRepStatElem = document.getElementById('nova-lab-rep-stat');
        const ghostsRepStatElem = document.getElementById('ghosts-rep-stat');
        const rafiRepStatElem = document.getElementById('rafi-rep-stat');

        // –≠–ª–µ–º–µ–Ω—Ç—ã –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–æ–≤
        const logicBar = document.getElementById('logic-bar');
        const empathyBar = document.getElementById('empathy-bar');
        const syncBar = document.getElementById('sync-bar');
        const novaLabRepBar = document.getElementById('nova-lab-rep-bar');
        const ghostsRepBar = document.getElementById('ghosts-rep-bar');
        const rafiRepBar = document.getElementById('rafi-rep-bar');

        // –≠–ª–µ–º–µ–Ω—Ç—ã –æ–±—Ä–∞—Ç–Ω–æ–π —Å–≤—è–∑–∏ –ø–æ –∏–∑–º–µ–Ω–µ–Ω–∏—é —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫
        const logicFeedback = document.getElementById('logic-feedback');
        const empathyFeedback = document.getElementById('empathy-feedback');
        const syncFeedback = document.getElementById('sync-feedback');
        const novaLabRepFeedback = document.getElementById('nova-lab-rep-feedback');
        const ghostsRepFeedback = document.getElementById('ghosts-rep-feedback');
        const rafiRepFeedback = document.getElementById('rafi-rep-feedback');

        const miniGameSectionElem = document.getElementById('mini-game-section');
        const miniGameTitleElem = document.getElementById('mini-game-title');
        const miniGameContentElem = document.getElementById('mini-game-content');
        const miniGameSubmitBtn = document.getElementById('mini-game-submit');
        const miniGameMessageElem = document.getElementById('mini-game-message');
        const saveGameButton = document.getElementById('save-game-button');
        const loadGameButton = document.getElementById('load-game-button');
        const openJournalButton = document.getElementById('open-journal-button');
        const journalModal = document.getElementById('journal-modal');
        const journalEntriesContainer = document.getElementById('journal-entries');
        const journalCloseButton = document.getElementById('journal-close-button');
        const transitionOverlay = document.getElementById('transition-overlay');

        const saveLoadModal = document.getElementById('save-load-modal');
        const saveLoadSlotsContainer = document.getElementById('save-load-slots-container');
        const saveLoadCloseButton = document.getElementById('save-load-close-button');

        const NUM_SAVE_SLOTS = 5;
        const AUTOSAVE_SLOT = 'autosave';
        const QUICKSAVE_SLOT = 'quicksave';

        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏–ª–∏ –ø–æ–ª—É—á–∞–µ–º Client ID
        let clientId = localStorage.getItem('psychobridge_clientId');
        if (!clientId) {
            clientId = 'player_' + Date.now() + '_' + Math.random().toString(36).substring(2, 15); // –£–Ω–∏–∫–∞–ª—å–Ω—ã–π ID –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∏–≥—Ä–æ–∫–∞
            localStorage.setItem('psychobridge_clientId', clientId);
        }
        console.log('–í–∞—à Client ID:', clientId);

        // –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        function updateStatsUI() {
            logicStatElem.textContent = clientGameState.logic;
            empathyStatElem.textContent = clientGameState.empathy;
            syncStatElem.textContent = clientGameState.synchronization;
            novaLabRepStatElem.textContent = clientGameState.reputationNovaLab;
            ghostsRepStatElem.textContent = clientGameState.reputationGhosts;
            rafiRepStatElem.textContent = clientGameState.reputationRafi;

            const maxPrimaryStat = 15;
            const maxReputation = 10;

            logicBar.style.width = `${(clientGameState.logic / maxPrimaryStat) * 100}%`;
            empathyBar.style.width = `${(clientGameState.empathy / maxPrimaryStat) * 100}%`;
            syncBar.style.width = `${(clientGameState.synchronization / maxPrimaryStat) * 100}%`;

            novaLabRepBar.style.width = `${(Math.max(0, clientGameState.reputationNovaLab) / maxReputation) * 100}%`;
            ghostsRepBar.style.width = `${(Math.max(0, clientGameState.reputationGhosts) / maxReputation) * 100}%`;
            rafiRepBar.style.width = `${(Math.max(0, clientGameState.reputationRafi) / maxReputation) * 100}%`;
        }

        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–∫–∞–∑–∞ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π (–±–µ–∑ –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞)
        function showTemporaryMessage(element, message, duration = 3000) {
            const originalContent = element.innerHTML;
            element.innerHTML = message;
            element.classList.remove('hidden');

            setTimeout(() => {
                element.innerHTML = originalContent;
                if (element.id === miniGameMessageElem.id) {
                   element.classList.add('hidden');
                }
            }, duration);
        }

        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–∫–∞–∑–∞ –æ–±—Ä–∞—Ç–Ω–æ–π —Å–≤—è–∑–∏ –ø–æ –∏–∑–º–µ–Ω–µ–Ω–∏—é —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫
        function showStatFeedback(statElementId, valueChange) {
            const feedbackElement = document.getElementById(statElementId + '-feedback');
            if (!feedbackElement) return;

            feedbackElement.textContent = (valueChange > 0 ? '‚¨ÜÔ∏è +' : '‚¨áÔ∏è ') + Math.abs(valueChange);
            feedbackElement.classList.remove('increase', 'decrease');
            if (valueChange > 0) {
                feedbackElement.classList.add('increase');
            } else if (valueChange < 0) {
                feedbackElement.classList.add('decrease');
            }
            feedbackElement.classList.add('show');

            setTimeout(() => {
                feedbackElement.classList.remove('show');
                feedbackElement.textContent = '';
            }, 1000);
        }

        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –¥–∞—Ç—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
        function formatSaveDate(timestamp) {
            if (!timestamp) return '–ü—É—Å—Ç–æ–π —Å–ª–æ—Ç';
            const date = new Date(timestamp);
            return date.toLocaleString('ru-RU', {
                year: 'numeric', month: 'numeric', day: 'numeric',
                hour: '2-digit', minute: '2-digit'
            });
        }

        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è/–∑–∞–≥—Ä—É–∑–∫–∏
        function openSaveLoadModal() {
            sendAction({ type: 'request_save_slots' });
        }

        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–∫—Ä—ã—Ç–∏—è –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è/–∑–∞–≥—Ä—É–∑–∫–∏
        function closeSaveLoadModal() {
            saveLoadModal.classList.add('hidden');
        }

        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è/–∑–∞–≥—Ä—É–∑–∫–∏
        function updateSaveLoadModal(slotsData) {
            saveLoadSlotsContainer.innerHTML = '';
            slotsData.forEach(slot => {
                addSaveLoadSlot(slot.id, slot.displayName, slot.data);
            });
            saveLoadModal.classList.remove('hidden');
        }

        function addSaveLoadSlot(slotName, displayName, slotData) {
            const slotElem = document.createElement('div');
            slotElem.classList.add('save-load-slot');

            let saveTime = null;
            let saveScenePreview = '';

            if (slotData && slotData.timestamp) {
                saveTime = slotData.timestamp;
                saveScenePreview = slotData.currentSceneDisplayName ? `–°—Ü–µ–Ω–∞: ${slotData.currentSceneDisplayName}` : '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è —Å—Ü–µ–Ω–∞';
            }

            slotElem.innerHTML = `
                <div class="save-load-slot-info">
                    <span class="font-bold">${displayName}:</span> ${formatSaveDate(saveTime)}<br>
                    <span class="text-sm text-gray-400">${saveScenePreview || '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö'}</span>
                </div>
                <div class="save-load-slot-buttons">
                    <button class="save-slot-button" data-slot="${slotName}">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
                    <button class="load-slot-button load" data-slot="${slotName}" ${!slotData ? 'disabled' : ''}>–ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
                </div>
            `;
            saveLoadSlotsContainer.appendChild(slotElem);
        }

        saveGameButton.addEventListener('click', openSaveLoadModal);
        loadGameButton.addEventListener('click', openSaveLoadModal);
        saveLoadCloseButton.addEventListener('click', closeSaveLoadModal);

        saveLoadSlotsContainer.addEventListener('click', (event) => {
            if (event.target.classList.contains('save-slot-button')) {
                const slot = event.target.dataset.slot;
                sendAction({ type: 'save_game', slotName: slot });
            } else if (event.target.classList.contains('load-slot-button')) {
                const slot = event.target.dataset.slot;
                sendAction({ type: 'load_game', slotName: slot });
            }
        });

        // –§—É–Ω–∫—Ü–∏—è –æ—Ç–∫—Ä—ã—Ç–∏—è –∂—É—Ä–Ω–∞–ª–∞
        function openJournal() {
            journalEntriesContainer.innerHTML = '';
            let hasEntries = false;
            for (const key in clientGameState.journal) {
                if (clientGameState.journal[key].unlocked) {
                    const entry = document.createElement('div');
                    entry.classList.add('journal-entry');
                    entry.innerHTML = `<h4>${clientGameState.journal[key].title}</h4><p>${clientGameState.journal[key].content}</p>`;
                    if (clientGameState.journal[key].key) {
                        entry.innerHTML += `<p class="font-mono text-green-400 mt-2">${clientGameState.journal[key].key}</p>`;
                    }
                    journalEntriesContainer.appendChild(entry);
                    hasEntries = true;
                }
            }
            if (!hasEntries) {
                journalEntriesContainer.innerHTML = '<p class="text-center text-gray-400">–ñ—É—Ä–Ω–∞–ª –ø—É—Å—Ç. –ù–∞—á–Ω–∏—Ç–µ —Å–≤–æ–µ –ø—Ä–∏–∫–ª—é—á–µ–Ω–∏–µ, —á—Ç–æ–±—ã —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –∑–∞–ø–∏—Å–∏!</p>';
            }
            journalModal.classList.remove('hidden');
        }

        function closeJournal() {
            journalModal.classList.add('hidden');
        }
        journalCloseButton.addEventListener('click', closeJournal);
        openJournalButton.addEventListener('click', openJournal);


        // –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–π –Ω–∞ –∫–ª–∏–µ–Ω—Ç–µ (–¥–ª—è –¥–∏–∑–µ–π–±–ª–∞ –∫–Ω–æ–ø–æ–∫)
        function checkRequirements(requirements) {
            if (!requirements) return true;
            for (const stat in requirements) {
                if (clientGameState.hasOwnProperty(stat) && clientGameState[stat] < requirements[stat]) {
                    return false;
                }
            }
            return true;
        }

        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ "–ø–µ—á–∞—Ç–∞–Ω–∏—è" —Ç–µ–∫—Å—Ç–∞
        let typeWriterIndex = 0;
        let typeWriterText = '';
        let typeWriterElement = null;
        let typeWriterSpeed = 20;

        function typeWriterEffect(element, text, speed) {
            typeWriterElement = element;
            typeWriterText = text;
            typeWriterSpeed = speed;
            typeWriterIndex = 0;
            typeWriterElement.innerHTML = '';
            typeNextCharacter();
        }

        function typeNextCharacter() {
            if (typeWriterIndex < typeWriterText.length) {
                if (typeWriterText.substring(typeWriterIndex, typeWriterIndex + 1) === '<') {
                    const tagEnd = typeWriterText.indexOf('>', typeWriterIndex);
                    if (tagEnd !== -1) {
                        typeWriterElement.innerHTML += typeWriterText.substring(typeWriterIndex, tagEnd + 1);
                        typeWriterIndex = tagEnd + 1;
                    } else {
                        typeWriterElement.innerHTML += typeWriterText.charAt(typeWriterIndex);
                        typeWriterIndex++;
                    }
                } else {
                    typeWriterElement.innerHTML += typeWriterText.charAt(typeWriterIndex);
                    typeWriterIndex++;
                }
                setTimeout(typeNextCharacter, typeWriterSpeed);
            }
        }


        // –§—É–Ω–∫—Ü–∏—è —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞ —Ç–µ–∫—É—â–µ–π —Å—Ü–µ–Ω—ã, –ø–æ–ª—É—á–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞
        const renderSceneFromData = (scene) => {
            if (!scene) {
                console.error("–î–∞–Ω–Ω—ã–µ —Å—Ü–µ–Ω—ã –Ω–µ –ø–æ–ª—É—á–µ–Ω—ã.");
                narrativeTextElem.innerHTML = "–û—à–∏–±–∫–∞: –î–∞–Ω–Ω—ã–µ —Å—Ü–µ–Ω—ã –Ω–µ –ø–æ–ª—É—á–µ–Ω—ã. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç–µ –∏–≥—Ä—É.";
                return;
            }

            transitionOverlay.classList.add('fade-out');

            setTimeout(() => {
                clientGameState.currentScene = scene.id;

                gameContainerElem.className = 'game-container';
                if (scene.background) {
                    gameContainerElem.classList.add(scene.background);
                }

                typeWriterEffect(narrativeTextElem, scene.text, 20);

                choicesContainerElem.innerHTML = '';
                miniGameSectionElem.classList.add('hidden');
                miniGameContentElem.innerHTML = '';
                miniGameSubmitBtn.classList.add('hidden');
                miniGameMessageElem.textContent = '';

                const textDisplayDuration = scene.text.length * typeWriterSpeed;
                setTimeout(() => {
                    if (scene.isEnding) {
                        const restartButton = document.createElement('button');
                        restartButton.classList.add('choice-button');
                        restartButton.textContent = '–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ';
                        restartButton.onclick = () => sendAction({ type: 'restart_game' });
                        choicesContainerElem.appendChild(restartButton);
                    } else if (scene.miniGame) {
                        startMiniGame(scene.miniGame.type, scene.miniGame.config);
                    } else if (scene.choices) {
                        scene.choices.forEach((choice, index) => {
                            const button = document.createElement('button');
                            button.classList.add('choice-button');
                            button.textContent = choice.text;
                            const requirementsMet = checkRequirements(choice.requirements);
                            button.disabled = !requirementsMet;
                            if (!requirementsMet) {
                                const requiredStats = Object.entries(choice.requirements).map(([stat, val]) => {
                                    let statName = '';
                                    if (stat === 'logic') statName = '–õ–æ–≥–∏–∫–∞';
                                    if (stat === 'empathy') statName = '–≠–º–ø–∞—Ç–∏—è';
                                    if (stat === 'synchronization') statName = '–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è';
                                    return `–¢—Ä–µ–±—É–µ—Ç—Å—è: ${statName} ${val}`;
                                }).join(', ');
                                button.title = requiredStats;
                            }

                            button.onclick = () => {
                                sendAction({
                                    type: 'make_choice',
                                    sceneId: clientGameState.currentScene,
                                    choiceIndex: index
                                });
                            };
                            choicesContainerElem.appendChild(button);
                        });
                    }
                }, textDisplayDuration + 100);

                transitionOverlay.classList.remove('fade-out');
            }, 800);
        };

        function renderSceneFromState(sceneId) {
            sendAction({ type: 'request_scene_data', sceneId: sceneId });
        }

        // –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ WebSocket
        const socket = new WebSocket("ws://abcd1234.ngrok.io:8080");
 // –ò–ª–∏ –≤–∞—à IP/–¥–æ–º–µ–Ω —Å–µ—Ä–≤–µ—Ä–∞

        socket.onopen = () => {
            console.log("üü¢ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ —Å–µ—Ä–≤–µ—Ä—É!");
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º Client ID –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏
            sendAction({ type: 'client_connect' });
            // –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –Ω–∞—á–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
            sendAction({ type: 'request_initial_state' });
        };

        socket.onmessage = (event) => {
            const message = JSON.parse(event.data);
            console.log("üì® –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞:", message);

            switch (message.type) {
                case 'game_state_update':
                    // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã –Ω–∞ –∫–ª–∏–µ–Ω—Ç–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å–µ—Ä–≤–µ—Ä–∞
                    Object.assign(clientGameState, message.state);
                    updateStatsUI();
                    // –í–∞–∂–Ω–æ: renderSceneFromState –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Å—Ü–µ–Ω–∞ –∏–∑–º–µ–Ω–∏–ª–∞—Å—å,
                    // –∏–ª–∏ –µ—Å–ª–∏ —ç—Ç–æ –ø–µ—Ä–≤–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è.
                    // –ò–∑–±–µ–≥–∞–µ–º –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞, –µ—Å–ª–∏ –ø—Ä–æ—Å—Ç–æ –æ–±–Ω–æ–≤–∏–ª–∏—Å—å —Å—Ç–∞—Ç—ã –±–µ–∑ —Å–º–µ–Ω—ã —Å—Ü–µ–Ω—ã.
                    if (clientGameState.currentScene !== message.state.currentScene || !document.getElementById('choices-container').hasChildNodes()) {
                        renderSceneFromState(message.state.currentScene);
                    }
                    break;
                case 'scene_data':
                    // –°–µ—Ä–≤–µ—Ä –ø—Ä–∏—Å—ã–ª–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ —Ç–µ–∫—É—â–µ–π —Å—Ü–µ–Ω—ã
                    renderSceneFromData(message.data);
                    break;
                case 'narrative_effect':
                    showTemporaryMessage(narrativeTextElem, message.narrative, 1500);
                    break;
                case 'mini_game_start':
                    startMiniGame(message.gameType, message.config);
                    break;
                case 'mini_game_message':
                    showTemporaryMessage(miniGameMessageElem, message.text, 1500);
                    break;
                case 'save_ack':
                    showTemporaryMessage(narrativeTextElem, message.message, 2000);
                    break;
                case 'save_slots_data':
                    // –û–±–Ω–æ–≤–ª—è–µ–º –º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è/–∑–∞–≥—Ä—É–∑–∫–∏ —Å –¥–∞–Ω–Ω—ã–º–∏, –ø–æ–ª—É—á–µ–Ω–Ω—ã–º–∏ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞
                    updateSaveLoadModal(message.slots);
                    break;
                case 'load_data':
                    // –≠—Ç–æ –±—É–¥–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –ø–æ–ª–Ω–æ–µ gameState –∏–∑ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö —Å–µ—Ä–≤–µ—Ä–∞
                    // –∏ –≤—ã–∑–æ–≤–µ—Ç –ø–æ–ª–Ω–æ–µ –ø–µ—Ä–µ—Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥
                    Object.assign(clientGameState, message.state);
                    // –í–∞–∂–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å –∂—É—Ä–Ω–∞–ª –Ω–∞ –æ—Å–Ω–æ–≤–µ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
                    // –°–µ—Ä–≤–µ—Ä —Ç–µ–ø–µ—Ä—å –ø—Ä–∏—Å—ã–ª–∞–µ—Ç –ø–æ–ª–Ω—ã–π –æ–±—ä–µ–∫—Ç journal, –∞ –Ω–µ —Ç–æ–ª—å–∫–æ journalUnlocked
                    clientGameState.journal = message.state.journal; // –ü–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–º–µ–Ω—è–µ–º
                    
                    updateStatsUI();
                    closeSaveLoadModal(); // –ó–∞–∫—Ä—ã–≤–∞–µ–º –º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏
                    renderSceneFromState(clientGameState.currentScene); // –†–µ–Ω–¥–µ—Ä–∏–º —Å—Ü–µ–Ω—É –∏–∑ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
                    showTemporaryMessage(narrativeTextElem, message.message, 2000);
                    break;
                case 'error':
                    showTemporaryMessage(narrativeTextElem, message.message, 3000);
                    console.error('–û—à–∏–±–∫–∞ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞:', message.message);
                    break;
                case 'server_broadcast': // –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –∞–¥–º–∏–Ω–∫–∏ –¥–ª—è –≤—Å–µ—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤
                    alert(`–°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞: ${message.message}`);
                    break;
            }
        };

        socket.onclose = () => {
            console.log("üî¥ –û—Ç–∫–ª—é—á–µ–Ω–æ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞.");
            showTemporaryMessage(narrativeTextElem, "–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å —Å–µ—Ä–≤–µ—Ä–æ–º –ø–æ—Ç–µ—Ä—è–Ω–æ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç–µ –∏–≥—Ä—É.", 5000);
        };

        socket.onerror = (error) => {
            console.error("‚ùå –û—à–∏–±–∫–∞ WebSocket:", error);
            showTemporaryMessage(narrativeTextElem, "–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å —Å–µ—Ä–≤–µ—Ä–æ–º. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ–Ω—Å–æ–ª—å.", 5000);
        };

        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –¥–µ–π—Å—Ç–≤–∏–π –Ω–∞ —Å–µ—Ä–≤–µ—Ä
        function sendAction(actionObject) {
            actionObject.clientId = clientId; // –î–æ–±–∞–≤–ª—è–µ–º clientId –∫ –∫–∞–∂–¥–æ–º—É —Å–æ–æ–±—â–µ–Ω–∏—é
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(actionObject));
            } else {
                console.warn("WebSocket –Ω–µ –æ—Ç–∫—Ä—ã—Ç. –ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ.");
            }
        }

        // –§–£–ù–ö–¶–ò–ò –ú–ò–ù–ò-–ò–ì–† (–±–æ–ª—å—à–µ–π —á–∞—Å—Ç—å—é –æ—Å—Ç–∞—é—Ç—Å—è –Ω–∞ –∫–ª–∏–µ–Ω—Ç–µ)
        function startMiniGame(gameType, config) {
            clientGameState.currentMiniGame = gameType;
            miniGameSectionElem.classList.remove('hidden');
            miniGameMessageElem.textContent = '';

            if (gameType === 'memoryHack') {
                startMemoryHackGame(config);
            } else if (gameType === 'decryptor') {
                startDecryptorGame(config);
            } else if (gameType === 'energyFlow') {
                startEnergyFlowGame(config);
            } else if (gameType === 'laserMaze') {
                startLaserMazeGame(config);
            }
        }

        function endMiniGame(success, outcomeConfig) {
            if (clientGameState.laserMaze.gameRunning) {
                clientGameState.laserMaze.gameRunning = false;
                cancelAnimationFrame(clientGameState.laserMaze.animationFrameId);
                document.removeEventListener('keydown', handleLaserMazeInput);
            }

            miniGameSectionElem.classList.add('hidden');
            miniGameContentElem.innerHTML = '';
            miniGameSubmitBtn.classList.add('hidden');

            sendAction({
                type: 'mini_game_result',
                game: clientGameState.currentMiniGame,
                success: success,
            });

            clientGameState.currentMiniGame = null;
        }


        // Memory Hack Mini-Game
        function startMemoryHackGame(config) {
            miniGameSectionElem.classList.remove('hidden');
            miniGameTitleElem.textContent = '–í–∑–ª–æ–º –ü–∞–º—è—Ç–∏: –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–π—Ç–µ –§—Ä–∞–≥–º–µ–Ω—Ç—ã';
            miniGameContentElem.innerHTML = '<div id="memory-grid" class="memory-grid"></div><p id="memory-attempts-left" class="text-sm text-gray-400 mt-2"></p>';
            miniGameSubmitBtn.classList.add('hidden');

            const memoryGridElem = document.getElementById('memory-grid');
            const attemptsLeftElem = document.getElementById('memory-attempts-left');

            clientGameState.memoryHack.cards = [];
            clientGameState.memoryHack.flippedCards = [];
            clientGameState.memoryHack.matchedPairs = 0;
            clientGameState.memoryHack.attempts = clientGameState.synchronization > 0 ? Math.floor(clientGameState.synchronization * 1.5) + 5 : 5;

            let shuffledSymbols = [...clientGameState.memoryHack.symbols, ...clientGameState.memoryHack.symbols];
            shuffledSymbols.sort(() => Math.random() - 0.5);

            shuffledSymbols.forEach((symbol, index) => {
                const card = document.createElement('div');
                card.classList.add('memory-card');
                card.dataset.symbol = symbol;
                card.dataset.index = index;
                card.innerHTML = `<div class="card-inner"><div class="card-face card-front"></div><div class="card-face card-back">${symbol}</div></div>`;
                memoryGridElem.appendChild(card);
                clientGameState.memoryHack.cards.push(card);

                card.addEventListener('click', () => flipCard(card, config));
            });
            attemptsLeftElem.textContent = `–ü–æ–ø—ã—Ç–æ–∫ –æ—Å—Ç–∞–ª–æ—Å—å: ${clientGameState.memoryHack.attempts}`;
        }

        function flipCard(card, config) {
            if (card.classList.contains('flipped') || card.classList.contains('matched') || clientGameState.memoryHack.flippedCards.length === 2) {
                return;
            }

            card.classList.add('flipped');
            clientGameState.memoryHack.flippedCards.push(card);

            if (clientGameState.memoryHack.flippedCards.length === 2) {
                clientGameState.memoryHack.attempts--;
                document.getElementById('memory-attempts-left').textContent = `–ü–æ–ø—ã—Ç–æ–∫ –æ—Å—Ç–∞–ª–æ—Å—å: ${clientGameState.memoryHack.attempts}`;
                const [card1, card2] = clientGameState.memoryHack.flippedCards;

                if (card1.dataset.symbol === card2.dataset.symbol) {
                    card1.classList.add('matched');
                    card2.classList.add('matched');
                    clientGameState.memoryHack.matchedPairs++;
                    clientGameState.memoryHack.flippedCards = [];
                    miniGameMessageElem.textContent = '–°–æ–≤–ø–∞–¥–µ–Ω–∏–µ! ‚úÖ';
                    miniGameMessageElem.classList.remove('hidden');

                    if (clientGameState.memoryHack.matchedPairs === clientGameState.memoryHack.symbols.length) {
                        setTimeout(() => {
                            endMiniGame(true, config.success);
                        }, 500);
                    }
                } else {
                    miniGameMessageElem.textContent = '–ù–µ —Å–æ–≤–ø–∞–ª–æ. ‚ùå';
                    miniGameMessageElem.classList.remove('hidden');
                    setTimeout(() => {
                        card1.classList.remove('flipped');
                        card2.classList.remove('flipped');
                        clientGameState.memoryHack.flippedCards = [];
                        miniGameMessageElem.classList.add('hidden');

                        if (clientGameState.memoryHack.attempts <= 0) {
                            endMiniGame(false, config.failure);
                        }
                    }, 1000);
                }
            }
        }

        // Decryptor Mini-Game
        function startDecryptorGame(config) {
            miniGameSectionElem.classList.remove('hidden');
            miniGameTitleElem.textContent = '–î–µ—à–∏—Ñ—Ä–∞—Ç–æ—Ä: –í–≤–µ–¥–∏—Ç–µ –ö–ª—é—á';
            miniGameContentElem.innerHTML = '<div id="decryptor-input-group" class="decryptor-input-group"></div>';
            miniGameSubmitBtn.classList.remove('hidden');

            const keyLength = config.correctKey.length;
            const inputGroup = document.getElementById('decryptor-input-group');
            clientGameState.decryptor.inputValues = Array(keyLength).fill('');

            for (let i = 0; i < keyLength; i++) {
                const input = document.createElement('input');
                input.type = 'text';
                input.maxLength = 1;
                input.classList.add('decryptor-input', 'bg-gray-700', 'text-white', 'p-2', 'rounded');
                input.dataset.index = i;
                input.addEventListener('input', (e) => {
                    e.target.value = e.target.value.toUpperCase();
                    clientGameState.decryptor.inputValues[i] = e.target.value;
                    if (e.target.value && i < keyLength - 1) {
                        inputGroup.children[i + 1].focus();
                    }
                });
                 input.addEventListener('keydown', (e) => {
                    if (e.key === 'Backspace' && e.target.value === '' && i > 0) {
                        inputGroup.children[i - 1].focus();
                    }
                });
                inputGroup.appendChild(input);
            }
            miniGameSubmitBtn.onclick = () => checkDecryptor(config);
        }

        function checkDecryptor(config) {
            const enteredKey = clientGameState.decryptor.inputValues.join('');
            if (enteredKey === config.correctKey) {
                miniGameMessageElem.textContent = '–ö–ª—é—á —É—Å–ø–µ—à–Ω–æ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω! ‚úÖ';
                miniGameMessageElem.classList.remove('hidden');
                endMiniGame(true, config.success);
            } else {
                miniGameMessageElem.textContent = '–ù–µ–≤–µ—Ä–Ω—ã–π –∫–ª—é—á. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ. ‚ùå';
                miniGameMessageElem.classList.remove('hidden');
                setTimeout(() => { miniGameMessageElem.classList.add('hidden'); }, 1500);
                endMiniGame(false, config.failure);
            }
        }

        // Energy Flow Mini-Game
        function startEnergyFlowGame(config) {
            miniGameSectionElem.classList.remove('hidden');
            miniGameTitleElem.textContent = '–ü–æ—Ç–æ–∫ –≠–Ω–µ—Ä–≥–∏–∏: –ë–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∫–∞ –¶–µ–ø–µ–π';
            miniGameContentElem.innerHTML = `
                <div class="energy-node">
                    <label>–£–∑–µ–ª 1 (–í—ã—Å–æ–∫–∏–π >8): <span id="energy-node1-value">${clientGameState.energyFlow.node1}</span></label>
                    <div class="energy-buttons">
                        <button data-node="node1" data-change="-1">-</button>
                        <button data-node="node1" data-change="1">+</button>
                    </div>
                </div>
                <div class="energy-node">
                    <label>–£–∑–µ–ª 2 (–ù–∏–∑–∫–∏–π <3): <span id="energy-node2-value">${clientGameState.energyFlow.node2}</span></label>
                    <div class="energy-buttons">
                        <button data-node="node2" data-change="-1">-</button>
                        <button data-node="node2" data-change="1">+</button>
                    </div>
                </div>
                <div class="energy-node">
                    <label>–£–∑–µ–ª 3 (–ù–∏–∑–∫–∏–π <3): <span id="energy-node3-value">${clientGameState.energyFlow.node3}</span></label>
                    <div class="energy-buttons">
                        <button data-node="node3" data-change="-1">-</button>
                        <button data-node="node3" data-change="1">+</button>
                    </div>
                </div>
                <p class="text-sm text-gray-400 mt-2">–í—Å–µ–≥–æ —ç–Ω–µ—Ä–≥–∏–∏: <span id="total-energy-value">${clientGameState.energyFlow.node1 + clientGameState.energyFlow.node2 + clientGameState.energyFlow.node3}</span></p>
                <p id="energy-flow-message" class="text-red-300"></p>
            `;
            miniGameSubmitBtn.classList.remove('hidden');
            miniGameSubmitBtn.textContent = '–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ë–∞–ª–∞–Ω—Å';

            const energyButtons = miniGameContentElem.querySelectorAll('.energy-buttons button');
            energyButtons.forEach(button => {
                button.addEventListener('click', (e) => adjustEnergy(e.target.dataset.node, parseInt(e.target.dataset.change), config));
            });
            miniGameSubmitBtn.onclick = () => checkEnergyFlow(config);
        }

        function adjustEnergy(node, change, config) {
            const currentNodeValue = clientGameState.energyFlow[node];
            // const currentTotalEnergy = clientGameState.energyFlow.node1 + clientGameState.energyFlow.node2 + clientGameState.energyFlow.node3;

            if (change < 0 && currentNodeValue <= 0) {
                 miniGameMessageElem.textContent = '–£–∑–µ–ª –ø—É—Å—Ç! ‚ö°';
                miniGameMessageElem.classList.remove('hidden');
                setTimeout(() => { miniGameMessageElem.classList.add('hidden'); }, 1500);
                return;
            }

            if (change > 0 && currentNodeValue >= 15) {
                 miniGameMessageElem.textContent = '–£–∑–µ–ª –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω! ‚ö°';
                miniGameMessageElem.classList.remove('hidden');
                setTimeout(() => { miniGameMessageElem.classList.add('hidden'); }, 1500);
                return;
            }


            clientGameState.energyFlow[node] += change;
            document.getElementById(`energy-${node}-value`).textContent = clientGameState.energyFlow[node];
            document.getElementById('total-energy-value').textContent = clientGameState.energyFlow.node1 + clientGameState.energyFlow.node2 + clientGameState.energyFlow.node3;
        }


        function checkEnergyFlow(config) {
            const node1 = clientGameState.energyFlow.node1;
            const node2 = clientGameState.energyFlow.node2;
            const node3 = clientGameState.energyFlow.node3;

            if (node1 > 8 && node2 < 3 && node3 < 3) {
                miniGameMessageElem.textContent = '–ë–∞–ª–∞–Ω—Å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω! ‚úÖ';
                miniGameMessageElem.classList.remove('hidden');
                endMiniGame(true, config.success);
            } else {
                miniGameMessageElem.textContent = '–ë–∞–ª–∞–Ω—Å –Ω–µ –¥–æ—Å—Ç–∏–≥–Ω—É—Ç. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ. ‚ùå';
                miniGameMessageElem.classList.remove('hidden');
                setTimeout(() => { miniGameMessageElem.classList.add('hidden'); }, 1500);
                endMiniGame(false, config.failure);
            }
        }


        // Laser Maze Mini-Game
        function startLaserMazeGame(config) {
            miniGameSectionElem.classList.remove('hidden');
            miniGameTitleElem.textContent = '–õ–∞–∑–µ—Ä–Ω—ã–π –õ–∞–±–∏—Ä–∏–Ω—Ç: –°—Ç–µ–ª—Å-–ü—Ä–æ–Ω–∏–∫–Ω–æ–≤–µ–Ω–∏–µ';
            miniGameContentElem.innerHTML = '<canvas id="laser-maze-canvas" width="600" height="400" class="border"></canvas>';
            miniGameSubmitBtn.classList.add('hidden');

            clientGameState.laserMaze.canvas = document.getElementById('laser-maze-canvas');
            clientGameState.laserMaze.ctx = clientGameState.laserMaze.canvas.getContext('2d');
            clientGameState.laserMaze.playerX = 50;
            clientGameState.laserMaze.playerY = clientGameState.laserMaze.canvas.height / 2;
            clientGameState.laserMaze.lasers = [];
            clientGameState.laserMaze.gameRunning = true;

            for (let i = 0; i < (clientGameState.synchronization > 8 ? 3 : 5); i++) {
                clientGameState.laserMaze.lasers.push({
                    x: Math.random() * (clientGameState.laserMaze.canvas.width - 100) + 100,
                    y: Math.random() * clientGameState.laserMaze.canvas.height,
                    length: 150,
                    direction: Math.random() < 0.5 ? 1 : -1
                });
            }

            document.addEventListener('keydown', handleLaserMazeInput);

            function gameLoop() {
                if (!clientGameState.laserMaze.gameRunning) {
                    cancelAnimationFrame(clientGameState.laserMaze.animationFrameId);
                    return;
                }
                updateLaserMaze();
                drawLaserMaze();
                clientGameState.laserMaze.animationFrameId = requestAnimationFrame(gameLoop);
            }

            function updateLaserMaze() {
                clientGameState.laserMaze.lasers.forEach(laser => {
                    laser.y += clientGameState.laserMaze.laserSpeed * laser.direction;
                    if (laser.y < 0 || laser.y > clientGameState.laserMaze.canvas.height) {
                        laser.direction *= -1;
                    }
                });

                clientGameState.laserMaze.lasers.forEach(laser => {
                    if (checkCollision(clientGameState.laserMaze.playerX, clientGameState.laserMaze.playerY, clientGameState.laserMaze.playerSize, laser)) {
                        clientGameState.laserMaze.gameRunning = false;
                        document.removeEventListener('keydown', handleLaserMazeInput);
                        endMiniGame(false, config.failure);
                    }
                });

                if (clientGameState.laserMaze.playerX + clientGameState.laserMaze.playerSize / 2 >= clientGameState.laserMaze.canvas.width - 20) {
                    clientGameState.laserMaze.gameRunning = false;
                    document.removeEventListener('keydown', handleLaserMazeInput);
                    endMiniGame(true, config.success);
                }
            }

            function drawLaserMaze() {
                const ctx = clientGameState.laserMaze.ctx;
                const canvas = clientGameState.laserMaze.canvas;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#e94560';
                ctx.fillRect(clientGameState.laserMaze.playerX - clientGameState.laserMaze.playerSize / 2, clientGameState.laserMaze.playerY - clientGameState.laserMaze.playerSize / 2, clientGameState.laserMaze.playerSize, clientGameState.laserMaze.playerSize);

                ctx.fillStyle = '#ff0000';
                clientGameState.laserMaze.lasers.forEach(laser => {
                    ctx.fillRect(laser.x, laser.y, 5, laser.length);
                });
            }

            function checkCollision(playerX, playerY, playerSize, laser) {
                return playerX < laser.x + 5 &&
                       playerX + playerSize > laser.x &&
                       playerY < laser.y + laser.length &&
                       playerY + playerSize > laser.y;
            }

            function handleLaserMazeInput(event) {
                const playerSpeed = 15;
                switch (event.key) {
                    case 'ArrowUp':
                    case 'w':
                    case 'W':
                        clientGameState.laserMaze.playerY = Math.max(0 + clientGameState.laserMaze.playerSize / 2, clientGameState.laserMaze.playerY - playerSpeed);
                        break;
                    case 'ArrowDown':
                    case 's':
                    case 'S':
                        clientGameState.laserMaze.playerY = Math.min(clientGameState.laserMaze.canvas.height - clientGameState.laserMaze.playerSize / 2, clientGameState.laserMaze.playerY + playerSpeed);
                        break;
                    case 'ArrowLeft':
                    case 'a':
                    case 'A':
                        clientGameState.laserMaze.playerX = Math.max(0 + clientGameState.laserMaze.playerSize / 2, clientGameState.laserMaze.playerX - playerSpeed);
                        break;
                    case 'ArrowRight':
                    case 'd':
                    case 'D':
                        clientGameState.laserMaze.playerX = Math.min(clientGameState.laserMaze.canvas.width - clientGameState.laserMaze.playerSize / 2, clientGameState.laserMaze.playerX + playerSpeed);
                        break;
                }
            }
            gameLoop();
        }

        window.onload = () => {
            sendAction({ type: 'request_initial_state' });
        };
    </script>
</body>
</html>